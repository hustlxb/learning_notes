# 学习笔记

## python log日志

### 自带logging库

```python
import loggging

# 设置log级别  INFO DEBUG
logging.basicConfig(level=logging.INFO)

```

## Markdown

>Markdown基本语法主要分为如下几大部分： 标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \，符号'`'

### 基本语法

**1 标题**

两种形式：

1）使用=和-标记一级和二级标题。

一级标题
=========
二级标题
---------

2）使用#，可表示1-6级标题。

# 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题

**2 段落**

段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。  

**3 区块引用**

在段落的每行或者只在第一行使用符号>,还可使用多个嵌套引用，如：
> 区块引用
>> 嵌套引用

**4 代码区块**

代码区块的建立是在每行加上4个空格或者一个制表符（即保留代码格式）。如

```
void main()
{
printf("Hello, Markdown.");
}
```

**5 强调**

在强调内容两侧分别加上*或者_，如：

>*斜体*，_斜体_

>**粗体**，__粗体__

**6 列表**

使用·、+、或-标记无序列表，如：

>- 第一项 
>+ 第二项 
>* 第三项

注意：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行

有序列表的标记方式是将上述的符号换成数字,并辅以.，如：
>1. 第一项
>2. 第二项
>3. 第三项

**7 分割线**

分割线最常使用就是三个或以上*，还可以使用-和_

>***
>---
>___

**8 链接**

链接可以由两种形式生成：行内式和参考式。

行内式：

>[younghz的Markdown库](https:://github.com/younghz/Markdown "Markdown")

参考式：

[younghz的Markdown库1][1]

[younghz的Markdown库2][2]

[1]:https:://github.com/younghz/Markdown "Markdown"
[2]:https:://github.com/younghz/Markdown "Markdown"

（以上即为我的参考源）

**9 图片**

添加图片的形式和链接相似，只需在链接的基础上前方加一个'！'

![海伦罗德里格斯特里亚斯诞辰89周年](https://i2.wp.com/www.wailian.work/images/2018/07/07/imageb3cd3.png?zoom=1.2999999523162842&w=810&ssl=1)
(正好看到谷歌首页推这个)

**10 反斜杠**

\ 相当于反转义作用,使符号成为普通符号,与代码中使用方式相同
 
**11. 符号 '`'**

起到标记作用。如：

`ctrl+a`

```
三个```即为引用区块
```
### 其他语法

**12. 表**
                                   
|    a    |       b       |      c     |
|:-------:| :-------------| ----------:|
|   居中   |     左对齐     |   右对齐    |
|=========|===============|============|

**13 在文章最后面显示脚注**

Markdown[^1]

[^1]: Markdown是一种纯文本标记语言    
    


## 正则表达式

https://docs.python.org/3.6/library/re.html
```
ordinary characters: 'A','a' or '0' and so on
special characters: '|' '('
Repetition qualifiers(重复限定符)： (*, +, ?, {m,n})

. 匹配任何一个字符 除了新行
^ 匹配字符串开头
$ 匹配字符串结尾

* 匹配0或多个重复字符 ab* --> a ab abb abbb abbbb
+ 匹配1或多个重复字符 ab+ -->   ab abb abbb abbbb
? 匹配0或1个字符     ab? --> a ab

*?, +?, ??  非贪婪(non-greedy) 尽可能少的匹配   
            <.*?> --> '<a>'  而 <.*> --> '<a> b <c>'

{m} 匹配m个重复字符   a{2} --> aa  a{6} --> aaaaaa 
{m,n} 匹配m-n个重复字符  a{2,4} --> aa, aaa, aaaa
{m,n}? 非贪婪(non-greedy) 尽可能少的匹配 a{2,4} --> aa

\  转义字符，将特殊字符转为常字符 \\ --> \ (代表'\'的字面意义)

[] 表示字符的集合  [amk]      --> 'a', 'm' or 'k'
   '-'表示范围    [a-z]      --> 小写字母集合 
                 [0-5][0-9] --> 00 to 59
                 [0-9A-Fa-f] --> 任何16进制数字
                 [a\-z] [-a] [a-] 中’-‘表示字面意思上的’-‘
                 [^5] --> 不包含5的字符串 [^^] --> '^'(’^'必须是第一个字符才有意义)
                 [()[\]{}] and []()[{}] --> 插入语(’]‘表示字面意思上的’]‘)

| 或 A|B --> 'A' or 'b'

(...) 匹配括号内的正则表达式 或者 表示组的开始和结束（租的内容在匹配后可被检索）

\d 匹配一个数字字符。等价于 [0-9]。
\D 匹配一个非数字字符。等价于 [^0-9]。
\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
\S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\w 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。
\W 匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。
```
待续 ...

## docker使用

**安装**

```shell
wget -qO- https://get.docker.com/ | sh
```
>If you would like to use Docker as a non-root user, you should now consider
adding your user to the "docker" group with something like:
```
 sudo usermod -aG docker runoob
```
>Remember that you will have to log out and back in for this to take effect!   
当要以非root用户可以直接运行docker时，需要执行 sudo usermod -aG docker runoob 命令，然后重新登陆，否则会有如下报错

**启动**

```bash
sudo service docker start
```

>docker:查看使用帮助  
docker COMMAND --help: 查看命令具体使用方法

## Caffe
### caffe编译

1. 将caffe根目录下的python文件夹加入到环境变量

>打开配置文件bashrc  
```bash
sudo vi ~/.bashrc  
```
>在后边加入  
```
export PYTHONPATH=/home/xxx/caffe/python:$PYTHONPATH
```
>保存，更新配置文件
```bash
sudo ldconfig
# 也可以使用
source ~/.bashrc
```
2. 编辑配置文件Makefile.config

```bash
## Refer to http://caffe.berkeleyvision.org/installation.html
# Contributions simplifying and improving our build system are welcome!

# 使用cuDNN加速时配置
# cuDNN acceleration switch (uncomment to build with cuDNN).
USE_CUDNN := 1

# 如果没有GPU,使用CPU配置时取消注释
# CPU-only switch (uncomment to build without GPU support).
# CPU_ONLY := 1

# uncomment to disable IO dependencies and corresponding data layers
# USE_OPENCV := 0
# USE_LEVELDB := 0
# USE_LMDB := 0

# uncomment to allow MDB_NOLOCK when reading LMDB files (only if necessary)
#    You should not set this flag if you will be reading LMDBs with any
#    possibility of simultaneous read and write
# ALLOW_LMDB_NOLOCK := 1

# Uncomment if you're using OpenCV 3
# OPENCV_VERSION := 3

# To customize your choice of compiler, uncomment and set the following.
# N.B. the default for Linux is g++ and the default for OSX is clang++
# CUSTOM_CXX := g++

# CUDA目录 包含bin/ 和 lib/ 目录
# CUDA directory contains bin/ and lib/ directories that we need.
CUDA_DIR := /usr/local/cuda
# On Ubuntu 14.04, if cuda tools are installed via
# "sudo apt-get install nvidia-cuda-toolkit" then use this instead:
# CUDA_DIR := /usr

# CUDA architecture setting: going with all of them.
# For CUDA < 6.0, comment the *_50 lines for compatibility.
CUDA_ARCH := -gencode arch=compute_20,code=sm_20 \
        -gencode arch=compute_20,code=sm_21 \
        -gencode arch=compute_30,code=sm_30 \
        -gencode arch=compute_35,code=sm_35 \
        -gencode arch=compute_50,code=sm_50 \
        -gencode arch=compute_50,code=compute_50

# BLAS choice:
# atlas for ATLAS (default)
# mkl for MKL
# open for OpenBlas
BLAS := atlas
# Custom (MKL/ATLAS/OpenBLAS) include and lib directories.
# Leave commented to accept the defaults for your choice of BLAS
# (which should work)!
# BLAS_INCLUDE := /path/to/your/blas
# BLAS_LIB := /path/to/your/blas

# Homebrew puts openblas in a directory that is not on the standard search path
# BLAS_INCLUDE := $(shell brew --prefix openblas)/include
# BLAS_LIB := $(shell brew --prefix openblas)/lib

# This is required only if you will compile the matlab interface.
# MATLAB directory should contain the mex binary in /bin.
# MATLAB_DIR := /usr/local
# MATLAB_DIR := /Applications/MATLAB_R2012b.app

# NOTE: this is required only if you will compile the python interface.
# We need to be able to find Python.h and numpy/arrayobject.h.

# 是要使用系统自带的python还是使用anaconda的环境

# PYTHON_INCLUDE := /usr/include/python2.7 \
        /usr/lib/python2.7/dist-packages/numpy/core/include
# Anaconda Python distribution is quite popular. Include path:
# Verify anaconda location, sometimes it's in root.
ANACONDA_HOME := $(HOME)/anaconda2
PYTHON_INCLUDE := $(ANACONDA_HOME)/include \
        $(ANACONDA_HOME)/include/python2.7 \
        $(ANACONDA_HOME)/lib/python2.7/site-packages/numpy/core/include \

# We need to be able to find libpythonX.X.so or .dylib.
# PYTHON_LIB := /usr/lib
PYTHON_LIB := $(ANACONDA_HOME)/lib

# Homebrew installs numpy in a non standard path (keg only)
# PYTHON_INCLUDE += $(dir $(shell python -c 'import numpy.core; print(numpy.core.__file__)'))/include
# PYTHON_LIB += $(shell brew --prefix numpy)/lib

# Uncomment to support layers written in Python (will link against Python libs)
WITH_PYTHON_LAYER := 1

# Whatever else you find you need goes here.
INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include
LIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib

# If Homebrew is installed at a non standard location (for example your home directory) and you use it for general dependencies
# INCLUDE_DIRS += $(shell brew --prefix)/include
# LIBRARY_DIRS += $(shell brew --prefix)/lib

# Uncomment to use `pkg-config` to specify OpenCV library paths.
# (Usually not necessary -- OpenCV libraries are normally installed in one of the above $LIBRARY_DIRS.)
# USE_PKG_CONFIG := 1

BUILD_DIR := build
DISTRIBUTE_DIR := distribute

# Uncomment for debugging. Does not work on OSX due to https://github.com/BVLC/caffe/issues/171
# DEBUG := 1

# The ID of the GPU that 'make runtest' will use to run unit tests.
TEST_GPUID := 0

# enable pretty build (comment to see full commands)
Q ?= @
```

```bash
sudo make test -j8
sudo make runtest -j8
```
>也许你在编译runtest的时候，会报这样的错误：
```python
.build_release/test/test_all.testbin: error while loading shared libraries: libhdf5.so.10: cannot open shared object file: No such file or directory
```
>这是因为 libhdf5.so的版本问题，你可以进入/usr/lib/x86_64-linux-gnu看一下，你的libhdf5.so.x中的那个x是多少，比如我的是libhdf5.so.7  
 
>可以执行下面几行代码解决:

```bash
cd /usr/lib/x86_64-linux-gnu
sudo ln -s libhdf5.so.7 libhdf5.so.10
sudo ln -s libhdf5_hl.so.7 libhdf5_hl.so.10
sudo ldconfig
```

>进入python环境，测试接口是否编译成功

```python
# python
>>> import caffe
```
若没有提示错误，说明编译成功

### caffe数据生成
**图像数据转换成db(leveldb/lmdb)文件**

>在caffe中，作者为我们提供了这样一个文件：convert_imageset.cpp，存放在根目录下的tools文件夹下。编译之后，生成对应的可执行文件放在 buile/tools/ 下面，这个文件的作用就是用于将图片文件转换成caffe框架中能直接使用的db文件  

>**使用格式：**

```python
 convert_imageset [FLAGS] ROOTFOLDER/ LISTFILE DB_NAME

# 四个参数：

# FLAGS: 图片参数组，后面详细介绍
# ROOTFOLDER/: 图片存放的绝对路径，从linux系统根目录开始
# LISTFILE: 图片文件列表清单，一般为一个txt文件，一行一张图片
# DB_NAME: 最终生成的db文件存放目录
```

>创建一个sh脚本文件，调用linux命令来生成图片清单(以caffe自带图片为例)

```bash
sudo vi examples/images/create_filelist.sh
```
```sh
# /usr/bin/env sh
DATA=examples/images
echo "Create train.txt..."
rm -rf $DATA/train.txt
find $DATA -name *cat.jpg | cut -d '/' -f3 | sed "s/$/ 1/">>$DATA/train.txt
find $DATA -name *bike.jpg | cut -d '/' -f3 | sed "s/$/ 2/">>$DATA/tmp.txt
cat $DATA/tmp.txt>>$DATA/train.txt
rm -rf $DATA/tmp.txt
echo "Done.."
```
>output:`train.txt`
```
cat.jpg 1
fish-bike.jpg 2
```
### 图片数据均值的计算
>为了提高提高速度和精度，一般都将图片减去均值后，再进行训练和测试


## ubuntu 18.04 

>Top Panel Workspace Scroll  
overflow Alt-Tab  
Dynamic Top Bar  
topicons plus 状态栏  
Screenshot tools 截图

- Arc Theme
- Flatabulous
- Arc-Flatabulous Theme
- OSX-Arc-Collection

>以上是几款扁平化的 Gnome Shell 主题，Arc-Flatabulous Theme 与 Arc Theme 相比具有更 加漂亮的窗口按钮。从名字即可看出 Arc-Flatabulous 是 Arc 和 Flatabulous 的结合。这三款 主题都托管于 GitHub： Arc Theme， Flatabulous， Arc-Flatabulous Theme。

## 课程学习

### python机器学习


Anaconda

jupyter: 打开ipthon文件

## one-hot 编码

``` python
from sklearn import preprocessing
enc = preprocessing.OneHotEncoder()
enc.fit([[0,0,3],[1,1,0],[0,2,1],[1,0,2]])
array = enc.transform([[0,1,3]]).toarray()
print "enc.n_values_ is:",enc.n_values_
print "enc.feature_indices_ is:",enc.feature_indices_
print array
```

```python
enc.n_values_ is: [2 3 4]
enc.feature_indices_ is: [0 2 5 9]
[[ 1.  0.  0.  1.  0.  0.  1.  0.  0.]]
```
